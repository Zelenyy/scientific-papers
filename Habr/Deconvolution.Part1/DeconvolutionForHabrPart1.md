# Статистическая регуляризация некорректных обратных задач им. Турчина. Часть 1

Привет, Хабр.

Сегодня мы хоти представить пост от одной из входящих в JetBrains Research лабораторий, а именно лаборатории методики ядерно-физического эксперимента.
Где JetBrains  и где ядерная физика спросите вы? Ну мы сошлись почве любви к Kotlin, хотя в данном посте о нем речи идти не будет. Дело во вполне объективных причинах, современный уровень финансирования Российской фундаментальной науки, мести оставляет желать лучшего и ка следствие многим исследователям приходиться акцентировать внимание на более дешевых исследованиях, в частности наша группа ориентируется на развитие методик анализа данных, моделирования и написание софта для ученных.

В этой статье мы как раз хотим поговорить об одном методе популяризуемом нашей группой: *статистической регуляризации*, созданного В.Ф. Турчинным в 70-х годах XX века, и реализации в виде кода на Python и Julia.

Оглавление (изложение будет достаточно подробным, поэтому для тех кому все очевидно с обратными задачами, могут сразу переходить к примера, а теорию прочитать в [этой статье](https://www.epj-conferences.org/articles/epjconf/abs/2018/12/epjconf_ayss2018_07005/epjconf_ayss2018_07005.html)):

* Возникновение проблемы: зачем вообще кого-то регуляризировать?
* Теоретическое описание статистической регуляризации
* Практические примеры на:
  * Python
  * Julia
* Заключение

## Возникновение проблемы: зачем вообще кого-то регуляризировать?

Если достаточно абстрагироваться, то любое измерение в эксперименте можно описать следующим образом: у нас есть некий прибор, которые фиксирует спектр или сигнал какого-либо процесса, и по результатам измерения показывает на какие-то цифры, наша задача как исследователей глядя на эти цифры и зная устройство прибора, понять а какой был измеряемый спектр или сигнал. То есть на лицо, то что называется *обратной задачей*. Если мы попробуем представить это математически, то получим вот такое уравнение (которое, кстати называется [уравнением Фредгольма I рода](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%83%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%A4%D1%80%D0%B5%D0%B4%D0%B3%D0%BE%D0%BB%D1%8C%D0%BC%D0%B0)):
$$
f(y) = \int \limits_a^b dx K(x,y)\varphi(x)
$$
Фактически, это уравнение описывает следующее: наш измерительный прибор представлен здесь своей аппаратной функцией $K(x,y)$, которая действует на исследуемый спектр или иной входной сигнал $\varphi$, в результате чего исследователь наблюдает выходной сигнал $f(y)$. Целью исследователя является восстановить сигнал $\varphi$ по известным $f(y)$ и $K(x,y)$. Так же можно сформулировать это выражение в матричной форме, заменив функции векторами и матрицами:
 $$
 f_m = K_{mn}\varphi_n
 $$
Казалось бы, восстановление сигнала не является сложной задачей, поскольку что уравнение Фредгольма, что система линейный уравнений (даже переопределенная) имеют точное решение.
Так давайте попробуем, пусть измеряемы сигнал описывается как сумма двух гауссов:
$$
\varphi(x) = 2*N(2, 0.16) + N(4, 0.04)
$$
В качестве прибора мы возьмем простейший интегратор --- матрицу переводящую наш сигнал в кумулятивную сумму  с помощи функции Хевисайда:
$$
K_{mn} = \theta(x_m-y_n)
$$
Вид измеряемого сигнал и нашего прибора, а так же результат измерения приведены на графике.

![]()

Важным моментом является, то что всякое реальное измерение имеет ошибки измерения, поэтому мы немного испортим наш результат измерения, добавив нормальный шум, дающий пятипроцентную ошибку измерения.
Восстанавливать сигнал мы будем методом наименьших квадратов:
$$
\varphi^{МНК} = (K^TK)^{-1}K^Tf
$$
И в результате мы получим:

![]()

Собственно на этом и можно было закончить статью, в очередной раз убедившись в бесполезности идеалистических методов математики перед суровой и безжалостной физической реальностью, и пойти раскуривать паяльники.
Но давайте сначала разберемся из-за чего сия неудача постигла нас? Очевидно дело в ошибках измерений, но что же они влияют? Дело в том что еще  Жак Адамар (тот самый, который добавил черточку в формулу Коши-Адамара) разделил все задачи на [корректно поставленные](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D0%BE_%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0) и некорректно. Вспомнив классиков: " Бессмыслица — искать решение, если оно и так есть. Речь идёт о том, как поступать с задачей, которая решения не имеет. Это глубоко принципиальный вопрос… ", мы не будет говорит о корректных задачах и сразу возьмемся за некорректные, благо мы уже выше встретили  такую: написанное нами выше уравнение Фредгольма является не корректной обратной задачей --- *даже при бесконечно малых флюктуациях во входных данных (а уж наши ошибки измерения далеко не бесконечно малые), решение уравнения полученное точным аналитическим образом может сколь угодно отличаться от истинного*. Доказательство этого утверждения вы можете прочитать в классическом труде академика А. Н Тихонова "Методы решения некорректных задач" в первой главе (оно хоть и требует некоторых познаний, но достаточно просто воспринимается). Как вы можете догадаться в этой книге есть советы что собственно делать с некорректными задачи, однако изложенная там методика имеет ряд недостатков, которые устранены в методе Турчина. Но для начала изложим общие принципы работы с некорректными задачи, что же надо делать если вам попалась такая задача? Поскольку сама задача не может нам ничего предложить, нам приходиться пойти на небольшое преступление: нужно дополнить задачу данными так, что бы она стала корректной или иначе говоря мы должны ввести какую-то *дополнительную априорную информацию о задаче* (этот процесс называется регуляризацией задачи). Но в отличии от классического метода Тихонова основанном на введение параметризованных регуляризирующих функционалов, метод Турчина заходит с другой стороны, используя байесовские методы.

## Теоретическое описание статистической регуляризации

### Стратегия

Сформулируем нашу задачу в терминах математической статистики: по известной реализации $f$ (которую мы измеряем в эксперименте) нам нужно оценить значение параметра $\varphi$. Функционал $\hat{S}$ вычисляющий $\varphi$ на основе $f$ мы будем называть *стратегией*. Для того чтобы определять какие стратегии более оптимальные мы введем *квадратичную функцию потерь* (реальная функция потерь может быть любой, почему же мы выбираем именно квадратичную? Потому что в близи минимум любую функцию потерь можно аппроксимировать квадратичной функцией):
$$
L(\varphi,\hat{S}[f]) = ||\hat{\varphi}-\hat{S}[f])||_{L_2},
$$
где $\hat{\varphi}$ --- наилучшее решение. Тогда потери для выбранной нами стратегии задаются *функцией риска*:
$$
R_{\hat{S}[f]}(\varphi) \equiv E[L(\varphi,\hat{S}[f])] = \int L(\varphi,\hat{S}[f])P(f|\varphi)df,  
$$
здесь $P(f|\varphi)$ определяет плотность вероятности нашего ансамбля по которому производится усреднение потерь. Этот ансамбль образован гипотетическим многократным повторением  измерений $f$ при заданном $\varphi$, таким образом $P(f|\varphi)$ это та самая известная нам плотность вероятности $f$, полученная в эксперименте.
Согласно Байессовскому подходу предлагается рассмотреть $\varphi$, как *случайную переменную* с *априорной плотностью вероятности* $P(\varphi)$, выражающую *достоверность* различных решений нашей задачи . $P(\varphi)$ определяется на основе информации, существующей до проведения эксперимента. Тогда выбор оптимальной стратегии основывается на минимизации *апостериорного риска*:
$$
r_{\hat{S}}(\varphi) \equiv E_{\varphi}E_{f}[L(\varphi,\hat{S}[f])|\varphi]
$$
В этом случае оптимальная стратегия хорошо известна:
$$
\hat{S}[f] = E[\varphi|f] = \int \varphi P(\varphi|f)d\varphi
$$
где *апостериорная плотность* $P(\varphi|f)$ определяется по теореме Баейса:
$$
P(\varphi|f)= \frac{P(\varphi)P(f|\varphi)}{\int d\varphi P(\varphi)P(f|\varphi)}
$$
Кроме того такой подход позволит определить дисперсию (корреляционную функцию) полученного решения:
$$
D(x_1,x_2)  = E[\varphi(x_1) - \hat{S}[f](x_1)][\varphi(x_2) - \hat{S}[f](x_2)]
$$
Итак мы получили оптимальное решение нашей задачи, введя априорную плотность $P(\varphi)$.  Можем ли мы сказать, что-либо о том мире функций $\varphi(x)$, который задается априорной плотностью? Если ответ на этот вопрос отрицательный, то мы должны будем принять все возможные $\varphi(x)$ равновероятными и вернуться к нерегуляризованному решению. Таким образом, мы должны ответить на этот вопрос положительно. Именно в этом заключается метод статистической регуляризации — регуляризация решения за счет введения дополнительной априорной информации о  $\varphi(x)$. Если исследователь уже обладает какой-либо априорной информацией (априорной плотностью $P(\vec{\varphi})$), он может просто вычислить интеграл и получить ответ. В случае, если такой информации нет, в следующем параграфе описывается, какой минимальной информацией может обладать исследователь и как её использовать для получения регулязованного решения.

### Априорная информация

Как показали британские ученые, во всем остальном мире любят дифференцировать. Причем, если математик будет задаваться вопросами о правомерности этой операции, то физик оптимистично верит, что законы природы описываются “хорошим” функциями, то есть гладкими. Иначе говоря, он назначает более гладким $\varphi(x)$ более высокую априорную плотность вероятности. Так давайте попробуем ввести априорную вероятность, основанную на гладкости. Для этого мы вспомним, что введение априорной информации — это некоторое насилие над миром, принуждающее законы природы выглядеть удобным для нас образом. Это насилие следует свести к минимуму, и, вводя априорную плотность вероятности, необходимо, что бы *информация Шеннона* относительно $\varphi(x)$, содержащаяся в $P(\vec{\varphi})$, была минимальной. Формализуя выше сказанное, выведем вид априорной плотности, основанной на гладкости функции. Для этого мы будем искать условный экстремум информации:
$$
I[P(\vec{\varphi})] = \int \ln{P(\vec{\varphi})}
P(\vec{\varphi}) d\vec{\varphi} \to min
$$
При следующих условиях:

1. Условие на гладкость $\varphi(x)$. Пусть
    $\Omega$ — некоторая матрица, характеризующая
    гладкость функции. Тогда потребуем, чтобы достигалось определённое
    значение функционала гладкости:
    $$
    \int(\vec{\varphi},\Omega\vec{\varphi}) P(\vec{\varphi})
    d\vec{\varphi} = \omega
    $$
    Внимательный
    читатель должен задать вопрос об определении значения параметра
    $\omega$. Ответ на него будет дан далее по
    тексту.
2. Нормированность вероятности на единицу:
$$
 \int     P(\vec{\varphi}) d\vec{\varphi} = 1
$$
При этих условиях доставлять минимум функционалу будет следующая
функция:
$$
P_{\alpha}(\vec{\varphi}) =
\frac{\alpha^{Rg(\Omega)/2}\det\Omega^{1/2}}{(2\pi)^{N/2}}
\exp(-\frac{1}{2}
(\vec{\varphi},\alpha\Omega\vec{\varphi}))
$$
Параметр $\alpha$ cвязан с $\omega$, но поскольку у нас нет собственно информации о конкретных значениях функционала гладкости, выяснять, как именно он связан, бессмысленно. Что же тогда делать с $\alpha$,
спросите вы? Здесь перед вами раскрываются три пути:

1. подбирать значение параметра $\alpha$ вручную, и тем самым фактически перейти к регуляризации Тихонова,
2. усреднить по всем возможным $\alpha$, предполагая все возможные $\alpha$ равновероятными,
3. выбрать наиболее вероятное $\alpha$ по его апостериорной плотности вероятности $P(\alpha|\vec{f})$. Этот подход верен, если мы предполагаем, что в экспериментальных данных содержится достаточно информации об $\alpha$.

Первый случай нам мало интересен. Во втором случае мы получим следующую формулу для решения:
$$
\left\langle \varphi_i \right\rangle = \frac{\int
d\varphi\, \varphi_i P(f|\varphi) \int\limits
d\alpha\,P(\alpha) \alpha^{\frac{Rg(\Omega)}{2}}
\exp(-\frac{\alpha}{2}
(\vec{\varphi},\Omega\vec{\varphi}))}{\int d\varphi P(f|\varphi)
\int\limits d\alpha\,P(\alpha) \alpha^{\frac{Rg(\Omega)}{2}}
\exp(-\frac{\alpha}{2}
(\vec{\varphi},\Omega\vec{\varphi}))}
$$
Для того что бы получить ответ нам нужно взять эти страшные интегралы

Третий случай будет рассмотрен в через раздел на примере гауссовых шумов в эксперименте.

Так же следует отметить, что мы собственно нигде пока не использовали, тот факт что $\Omega$ --- это оператор гладкости, на самом деле мы можем использовать здесь любой другой оператор (или их линейную комбинацию), просто гладкость функции это наиболее очевидный вид априорной информации, который мы можем использовать.

### Дискретизация

Как вы заметили мы говорил о функциях, но любой реальный прибор не может измерить не то что континуальное, но и даже счетное множество точек. Мы всегда проводим измерение в конченом наборе точек, поэтому мы вынуждены проводить процедуры дискретизации и перехода от интегрально уравнения к матричному,  в методе статистической регуляризации мы поступаем следующим образом:  мы будем раскладывать $\varphi(x)$ по некоторой системе функций $\{T_n\}$:
$$
\varphi(x) = \sum \limits_n \varphi_n T_n(x).
$$
Таким образом  коэффициенты этого разложения образуют некоторый вектор $\vec{\varphi}$, который является вектор в функциональном пространстве.
В качестве функционального пространства можно взять гильбретоо пространство , а можно например пространство полиномов, причем выбор базиса в этих пространствах ограничен только вашей фантазией (мы пробовали работать с тригонометрическим фурье, полижандрами и с кубическими сплайнами)

 Тогда элементы матрицы $K$, вычисляются как:
$$
K_{mn} = (\hat{K}T_n(x))(y_m),
$$
где $y_m$ --- точки в которых производились измерения. Элементы матрицы $\Omega$ будем вычислять по формуле:
$$
\Omega_{ij} = \int\limits_a^b \left(\frac{d^pT_i(x)}{dx}\right)\left(\frac{d^pT_j(x)}{dx}\right)dx,
$$
где $a$ и $b$ границы интервала на котором определена функция $\varphi(x)$.
Для перерасчета ошибок следует использовать формулу дисперсии линейной комбинации случайных величин:
$$
D[\varphi(x)] = D[\sum \limits_n \varphi_n T_n(x)] = \sum\limits_{i,j} \varphi_i\varphi_j cov(T_i(x), T_j(x)).
$$
При этом нужно учитывать, что в некоторых случаях представление функции при помощи вектора конечной размерности приводит к частичной потере или изменению информации, фактически мы можем считать алгебраизацию разновидностью регуляризации, однако слабой и недостаточной для превращения некорректной задачи в корректную. Но так или иначе мы теперь перешли от поиска $\varphi(x)$ к поиску вектора $\vec{\varphi}$, и в следующем разделе найдем таки его.

### Случай гауссовых шумов

Случай, когда ошибки в эксперименте распределены по Гауссу, замечателен
тем, что можно получить аналитическое решение нашей задачи. Решение и
его ошибка будут иметь следующий вид:
$$
 \vec{\varphi} = (K^T\Sigma^{-1}K + \alpha^*\Omega)^{-1}K^T\Sigma^{-1^{T}}\vec{f}
$$
$$
\Sigma_{\vec{\varphi}} = (K^T\Sigma^{-1}K+\alpha^*\Omega)^{-1}
$$
 где $\Sigma$ - ковариационная матрица многомерного
распределения Гаусса, $\alpha^*$ - наиболее
вероятное значение параметра $\alpha$, которое
определяется из условия максимума апостериорной плотности вероятности:
$$
P(\alpha|\vec{f}) = C'\alpha^{\frac{Rg(\Omega)}{2}}\sqrt{|(K^T\Sigma^{-1}K+\alpha\Omega)^{-1}|}\exp(\frac{1}{2}
\vec{f}^T\Sigma^{-1}K^{T}(K^T\Sigma^{-1}K+\alpha\Omega)^{-1}K^T\Sigma^{-1^{T}}\vec{f})
$$

## Практическая часть

Первая реализация метода статистической регуляризации була написана в 70-х еще на Алголе и успешно использовался для расчетов в атмосферной физике. Не смотря на то что у нас остались рукописные исходники алгоритма, мы решили добавить немного модернизма и сделать реализацию на Python, а затем и на Julia.

### Python

#### Установка

Устанавливаем через pip:

```sh
pip install statreg
```

Или качаем исходный [код](https://github.com/mipt-npm/statreg-py).

#### Примеры

В качестве примеров мы рассмотрим как использовать модуль `stareg`, для восстановление данных для матричного и интегрального уравнения.

Импортируем научные пакеты.

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from scipy.integrate import quad
%matplotlib inline
```

Определяем наш истинный сигнал, который мы будем восстанавливать.

```python
a = 0
b = 5
# Восстанавливаемый сигнал
phi = lambda x: 4*norm.pdf(x-2, scale=0.4) + 2*norm.pdf(x-4, scale = 0.5)
x = np.linspace(a, b,100)
plt.plot(x, phi(x));
```

![png](output_2_0.png)

Определим ядро и операцию свертки функций (Примечание: `np.convolution` определенно для массивов):

```python
kernel = lambda x,y : np.heaviside(x-y, 1) # Ядро уравнения
convolution =  np.vectorize(lambda y: quad(lambda x: kernel(x,y)*phi(x), a,b)[0])
```

Генерируем измеренные данные и зашумляем их с помощью нормального распределения

```python
y = np.linspace(a, b, 50)
ftrue = convolution(y)
sig = 0.05*ftrue +0.01 # Ошибка измерения
f = norm.rvs(loc = ftrue, scale=sig)
plt.errorbar(y, f, yerr=sig);
```

![png](output_9_0.png)

#### Решаем интегральное уравнение

Импортируем решатель и вспомогательный класс для дискретизации:

```python
from statreg.model import GaussErrorUnfolder
from statreg.basis import CubicSplines
```

Как функциональный базис для дискретизации мы используем кубические сплайны, причем в качестве дополнительного условия мы укажем, что функция принимает на края нулевые значения.

```python
basis = CubicSplines(y, boundary='dirichlet')
model = GaussErrorUnfolder(basis, basis.omega(2))
```

Решаем уравнение:

```python
phi_reconstruct = model.solve(kernel, f, sig, y)
```

Строим график решения:

```python
plt.plot(x,phi(x))
phir = phi_reconstruct(x)
phiEr = phi_reconstruct.error(x)
plt.plot(x, phir, 'g')
plt.fill_between(x, phir-phiEr, phir + phiEr, color='g', alpha=0.3);
```

![png](output_14_0.png)

#### Решаем матричное уравнение

Импортируем решатель и вспомогательный класс для дискретизации:

```python
from statreg.model import GaussErrorMatrixUnfolder
from statreg.basis import CubicSplines
```

Для получения матриц, мы используем наш функциональный базис, но понятно дело матрицы могут быть получены каким угодно путем.

```python
cubicSplines = CubicSplines(y, boundary='dirichlet')
omega = cubicSplines.omega(2)
Kmn = cubicSplines.discretizeKernel(kernel,y)
```

Решаем матричное уравнение:

```python
model = GaussErrorMatrixUnfolder(omega)
result = model.solve(Kmn, f, sig)
```

Строим график:

```python
phir = lambda x: sum([p*bf(x) for p, bf in zip(result.phi,cubicSplines.basisFun)])
plt.plot(x,phir(x))
plt.plot(x,phi(x));
```

![png](output_23_0.png)

### Julia

Как мы упоминали для дальнейшего развития методики требуется продвинутые методы Монте-Карло моделирования, мы могли бы использовать какой-либо модуль на Python (например, мы проводили работу с PyMC3), но мы помимо прочего участвуем в совместном проекте с институтом Макса Планка в Мюнхене. Этот проект называется [Bayesian Analysis Toolkit](https://github.com/bat/BAT.jl) - , его цель создание фреймворка с инструментами для байесовких методов анализа и в первую очередь включается себя инструменты для MCMC. Сейчас команда работает над второй версией фреймворка, которая пишется на Julia (первая написана на C++), и одна из задач нашей группы это демонстрация возможностей этого фреймворка на примере статистической регуляризации, поэтому мы написали реализацию на Julia.

```julia
using PyCall
include("../src/gauss_error.jl")
include("../src/kernels.jl")

a = 0.
b = 6.

function phi(x::Float64)
    mu1 = 1.
    mu2 = 4.
    n1 = 4.
    n2 = 2.
    sig1 = 0.3
    sig2 = 0.5

    norm(n, mu, sig, x) = n / sqrt(2 * pi*sig^2) * exp(-(x - mu)^2 / (2 * sig^2))
    return norm(n1, mu1, sig1, x) + norm(n2, mu2, sig2, x)
end
x = collect(range(a, stop=b, length=300))

import PyPlot.plot

myplot = plot(x, phi.(x))
savefig("function.png", dpi=1000)
```

![png](output_0_0.png)

На этот раз используем другое ядро, будем брать не интегрирующее ступеньку, а свертку с гауссом, которая фактическим наводит некий "блюр" на наши данные:

```julia
function kernel(x::Float64, y::Float64)
    return getOpticsKernels("gaussian")(x, y)
end

convolution = y -> quadgk(x -> kernel(x,y) * phi(x), a, b, maxevals=10^7)[1]
y = collect(range(a, stop = b, length=50))
ftrue = convolution.(y)
sig = 0.05*abs.(ftrue) +[0.01 for i = 1:Base.length(ftrue)]
using Compat, Random, Distributions
noise = []
for sigma in sig
    n = rand(Normal(0., sigma), 1)[1]
    push!(noise, n)
end
f = ftrue + noise
plot(y, f)
```

![png](output_2_0.png)

Аналогично возьмем базис сплайнов с закрепленными концами:

```julia
basis = CubicSplineBasis(y, "dirichlet")
Kmn = discretize_kernel(basis, kernel, y)
model = GaussErrorMatrixUnfolder([omega(basis, 2)], "EmpiricalBayes", nothing, [1e-5], [1.], [0.5])
result = solve(model, Kmn, f, sig)
phivec = PhiVec(result, basis)

x = collect(range(a, stop=b, length=5000))
plot(x, phi.(x))

phi_reconstructed = phivec.phi_function.(x)
phi_reconstructed_errors = phivec.error_function.(x)

plot(x, phi_reconstructed)
fill_between(x, phi_reconstructed - phi_reconstructed_errors, phi_reconstructed + phi_reconstructed_errors, alpha=0.3)
```

![png](output_8_0.png)

## Выводы и анонс следующей части

В нашей статье сделан обзор полезной методики, которую можно адаптировать под многие задачи анализа данных (в том  числе машинного обучения), причем получить честную "подгонку" ответа --- наиболее рациональное решение уравнение в условиях неопределенности вызванной ошибками измерения. Как очень приятный бонус мы получаем значения для ошибки решения. Желающие участвовать в развитии или применять метод статистической регуляризации, могут внести свой вклад в виде кода на Python, Julia или чём-нибудь ещё.

В следующей части мы поговорим о:

* Использовании MCMC
* Разложение Холецкого
* В качестве практического примера рассмотрим применение регуляризации для обработки сигнала с модели орбитального детектора протонов и электронов

## Ссылки

* []()
* []()
* []()
* []()
* []()
